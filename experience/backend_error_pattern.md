# 后端开发通用错误模式与解决方案（backend_error_patterns.md）

> **定位**  
> 通用后端工程错误模式库（偏 FastAPI / Web API / DB / 外部依赖集成），用于提高开发效率与正确率。  
>
> **优先级声明**  
> 当 IDE / AI 的建议与本文档冲突时，**以本文档为准**。  
>
> **联动规则**  
> - FastAPI 相关实现必须同时遵守 `fastapi_backend_rules.md`  
> - 产品决策必须遵守 `ai_product_decisions.md`  
> - 若涉及 RAG/向量库，额外参考 `rag_error_patterns.md`

---

## 模式 1：错误处理不统一导致“前端无法接”与“难排查”

### 问题本质
后端错误返回结构不稳定（有时 string、有时 dict、有时直接抛异常），会导致：
- 前端无法稳定渲染错误提示
- 日志与问题定位困难
- 同类错误在不同接口表现不一致

### 典型信号
- 前端出现 “undefined / null” 错误信息
- 同样的错误在 A 接口是 500，在 B 接口是 400
- 线上只能看到“Internal Server Error”，不知道原因

### 通用解决思路
**原则：统一错误 envelope + 全局异常处理器 + request_id 贯穿**

**实现模式（示意）**
```py
class AppError(Exception):
    def __init__(self, code: str, message: str, status_code: int = 400, details: dict | None = None):
        self.code = code
        self.message = message
        self.status_code = status_code
        self.details = details or {}
检查清单

 所有对外错误统一 envelope

 全局异常处理器覆盖 AppError / 未知异常

 响应与日志携带 request_id

模式 2：在 route 层堆业务逻辑导致“越改越乱”
问题本质
把复杂业务逻辑写进 FastAPI 路由，会让：

单测难写（只能集成测）

复用困难

改动牵一发而动全身

典型信号
一个接口文件 300+ 行

改一个业务规则要改 3 个接口

逻辑难以复用到 CLI/后台任务

通用解决思路
分层强约束：routes → services → repos

检查清单

 route 只做：校验/鉴权/调用 service/返回响应

 service 聚合业务逻辑

 repo 专注 DB 访问

模式 3：外部调用无超时导致“请求挂死”
问题本质
调用外部服务（LLM / HTTP / 向量库 / DB）不设 timeout，会导致：

请求线程被占住

队列堆积、吞吐下降

用户感觉“系统卡死”

典型信号
接口偶发超长耗时（>30s）

负载上升后大量超时/502

日志里无明确异常，但请求没结束

通用解决思路
必须设置超时 + 可控重试 + 降级策略

检查清单

 每个外部调用都有 timeout

 仅对可重试错误重试（网络超时、连接错误）

 重试次数上限 + 指数退避

 高成本调用（LLM）默认不自动重试，或需幂等键

模式 4：重复提交导致“重复写入/重复扣费”
问题本质
前端/网关/用户刷新会触发重试，导致：

创建接口重复插入数据

LLM 调用重复扣费

状态机被推进两次

典型信号
同一用户短时间产生重复订单/记录

用户说“我就点了一次”

日志显示同一 payload 被处理两次

通用解决思路
幂等性：idempotency key / 唯一约束 / 业务去重

检查清单

 创建类接口有唯一约束或去重策略

 高成本外部调用支持幂等键（或在 DB 里做去重）

 对重试友好（返回同一结果）

模式 5：事务缺失导致“半成功状态”
问题本质
多步 DB 写入没有事务会导致：

步骤 1 成功，步骤 2 失败

数据处于不可恢复的中间态

典型信号
数据库里出现“孤儿记录”

系统偶发状态不一致，需要手动修复

线上出现难以复现的脏数据

通用解决思路
涉及原子性的写操作必须事务化

检查清单

 多表写入使用事务

 失败必回滚

 事务边界在 service 层清晰可见

模式 6：数据库连接/会话管理不当导致“连接泄漏”
问题本质
DB session 没关闭或连接池配置不当，会导致：

连接耗尽

请求开始大量失败

服务重启才恢复

典型信号
“too many connections”

运行一段时间后错误率上升

性能逐步劣化（内存/句柄上涨）

通用解决思路
依赖注入管理 session + 明确连接池配置 + 监控

检查清单

 每个请求生命周期内正确创建/关闭 session

 连接池参数合理（max_overflow/pool_size）

 关键指标可观测（连接数、等待时间）

模式 7：Schema / Response 不声明导致“契约漂移”
问题本质
不使用 response_model 或随意返回 dict，会导致：

前端/调用方难以稳定依赖

文档（OpenAPI）失真

迭代中出现隐性破坏

典型信号
前端经常改适配

接口文档与实际返回不一致

不同接口字段命名风格不一

通用解决思路
强制 schema 契约：入参/出参都用 Pydantic

检查清单

 所有请求体都有 schema

 所有响应都有 response_model

 字段命名统一（snake_case / camelCase 明确选择）

模式 8：日志缺少上下文导致“查不到是谁的问题”
问题本质
只有 “error happened”，没有 request_id / user_id / path / cost_ms，定位会非常痛苦。

典型信号
线上报错只能靠猜

无法关联一次请求的全链路日志

无法确认错误影响范围

通用解决思路
结构化日志 + request_id 贯穿 + 关键耗时点打点

检查清单

 每条请求都有 request_id

 日志至少包含 path、status_code、cost_ms

 不记录敏感信息（token、明文隐私）

模式 9：CORS / Auth 配置错误导致“本地可用上线崩”
问题本质
本地开发与生产环境差异大：

CORS 放太开/太死

鉴权依赖在某些环境未生效

代理/网关改写 header

典型信号
本地 OK，部署后前端请求全失败

401/403 大量出现但后端无清晰日志

OPTIONS 预检失败

通用解决思路
环境差异显式化 + 配置集中化 + 预检/鉴权单测

检查清单

 CORS 配置按环境区分

 鉴权依赖显式挂载到路由

 针对 OPTIONS/401/403 有测试用例

通用调试流程（强制执行）
1) 明确症状（错误信息、状态码、请求参数、耗时）
2) 最小复现（curl / Postman / 单测）
3) 隔离变量（DB/外部服务/权限/网络）
4) 验证假设（脚本/日志/临时开关）
5) 修复回归（至少 1 条 happy + 1 条 failure）
6) 沉淀规则（追加到本文档或 fastapi_backend_rules.md）
后端快速检查清单（MVP 必备）
设计阶段
 接口契约是否稳定（schema）

 错误返回是否统一

 是否需要幂等性

实施阶段
 外部调用是否有 timeout

 是否有 request_id 与结构化日志

 多步写入是否事务化

测试阶段
 每个核心接口至少 1 条 happy path

 至少 1 条失败路径（400/401/404/422）

 部署后验证 CORS / 鉴权 / 代理

复利更新规则（必须）
当出现以下任一情况必须追加规则：

一个后端问题调试 ≥ 30 分钟

同类错误重复出现

演示/线上出现不可控失败

只追加，不重写；写规则，不写日记。 